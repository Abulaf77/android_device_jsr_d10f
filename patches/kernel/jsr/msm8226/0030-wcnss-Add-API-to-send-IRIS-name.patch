From b4475980d94741e10e07fca6a5f7c3ba4744aaf3 Mon Sep 17 00:00:00 2001
From: Anand N Sunkad <asunka@codeaurora.org>
Date: Thu, 30 Apr 2015 21:27:06 +0530
Subject: [PATCH 30/31] wcnss: Add API to send IRIS name

As per requirment, user need to check WLAN RF card
preset on device at run time. WLAN host driver use
this API to get the IRIS card name.

CRs-Fixed: 831585
Change-Id: I8bd71cab7f998cde01bd43068b8dfbfc5817fb7f
Signed-off-by: Anand N Sunkad <asunka@codeaurora.org>
---
 drivers/net/wireless/wcnss/wcnss_vreg.c | 50 +++++++++++++++++++++++++++++++++
 include/linux/wcnss_wlan.h              |  2 ++
 2 files changed, 52 insertions(+)

diff --git a/drivers/net/wireless/wcnss/wcnss_vreg.c b/drivers/net/wireless/wcnss/wcnss_vreg.c
index 599318e..e42027b 100644
--- a/drivers/net/wireless/wcnss/wcnss_vreg.c
+++ b/drivers/net/wireless/wcnss/wcnss_vreg.c
@@ -148,6 +148,50 @@ int xo_auto_detect(u32 reg)
 	}
 }
 
+int wcnss_get_iris_name(char *iris_name)
+{
+	struct wcnss_wlan_config *cfg = NULL;
+	int iris_id;
+
+	cfg = wcnss_get_wlan_config();
+
+	if (cfg) {
+		iris_id = cfg->iris_id;
+		iris_id = iris_id >> 16;
+	} else {
+		return 1;
+	}
+
+	switch (iris_id) {
+	case WCN3660:
+		memcpy(iris_name, "WCN3660", sizeof("WCN3660"));
+		break;
+	case WCN3660A:
+		memcpy(iris_name, "WCN3660A", sizeof("WCN3660A"));
+		break;
+	case WCN3660B:
+		memcpy(iris_name, "WCN3660B", sizeof("WCN3660B"));
+		break;
+	case WCN3620:
+		memcpy(iris_name, "WCN3620", sizeof("WCN3620"));
+		break;
+	case WCN3620A:
+		memcpy(iris_name, "WCN3620A", sizeof("WCN3620A"));
+		break;
+	case WCN3610:
+		memcpy(iris_name, "WCN3610", sizeof("WCN3610"));
+		break;
+	case WCN3610V1:
+		memcpy(iris_name, "WCN3610V1", sizeof("WCN3610V1"));
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(wcnss_get_iris_name);
+
 int validate_iris_chip_id(u32 reg)
 {
 	int iris_id;
@@ -197,6 +241,9 @@ static int configure_iris_xo(struct device *dev, bool use_48mhz_xo, int on,
 	void __iomem *iris_read_reg;
 	struct clk *clk;
 	struct clk *clk_rf = NULL;
+        struct wcnss_wlan_config *cfg = NULL;
+
+        cfg = wcnss_get_wlan_config();
 
 	if (wcnss_hardware_type() == WCNSS_PRONTO_HW) {
 		wcnss_phys_addr = MSM_PRONTO_PHYS;
@@ -308,6 +355,9 @@ static int configure_iris_xo(struct device *dev, bool use_48mhz_xo, int on,
 		else
 			auto_detect = WCNSS_XO_INVALID;
 
+                if (cfg != NULL)
+		    cfg->iris_id = iris_reg;
+
 		/* Clear XO_MODE[b2:b1] bits. Clear implies 19.2 MHz TCXO */
 		reg &= ~(WCNSS_PMU_CFG_IRIS_XO_MODE);
 
diff --git a/include/linux/wcnss_wlan.h b/include/linux/wcnss_wlan.h
index 675c85a..cfa9285 100644
--- a/include/linux/wcnss_wlan.h
+++ b/include/linux/wcnss_wlan.h
@@ -29,6 +29,7 @@ enum wcnss_hw_type {
 struct wcnss_wlan_config {
 	int		use_48mhz_xo;
 	int	is_pronto_v3;
+	int	iris_id;
 };
 
 enum {
@@ -92,6 +93,7 @@ u32 wcnss_get_wlan_rx_buff_count(void);
 int wcnss_wlan_iris_xo_mode(void);
 void wcnss_flush_work(struct work_struct *work);
 void wcnss_flush_delayed_work(struct delayed_work *dwork);
+int wcnss_get_iris_name(char *iris_version);
 
 #ifdef CONFIG_WCNSS_REGISTER_DUMP_ON_BITE
 void wcnss_log_debug_regs_on_bite(void);
-- 
2.5.0

