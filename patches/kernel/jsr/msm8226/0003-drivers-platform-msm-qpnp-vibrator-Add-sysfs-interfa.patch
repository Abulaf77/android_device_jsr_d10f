From 945e661f5a1af854ec0ed94e8b27a86f0b00d28a Mon Sep 17 00:00:00 2001
From: SpaceKiller <alexisalbo.1@gmail.com>
Date: Sun, 19 Jan 2014 18:42:10 -0300
Subject: [PATCH 3/7] drivers: platform: msm: qpnp-vibrator: Add sysfs
 interface for intensity

To control the Haptic intensity using sysfs interface.

Change-Id: If0ccd421b6dbe0d0602f427af12f08dab2235036
Signed-off-by: SpaceKiller <alexisalbo.1@gmail.com>
---
 drivers/platform/msm/qpnp-vibrator.c | 46 ++++++++++++++++++++++++++++++++++++
 1 file changed, 46 insertions(+)

diff --git a/drivers/platform/msm/qpnp-vibrator.c b/drivers/platform/msm/qpnp-vibrator.c
index ca3832d..fe8c245 100644
--- a/drivers/platform/msm/qpnp-vibrator.c
+++ b/drivers/platform/msm/qpnp-vibrator.c
@@ -10,6 +10,7 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/device.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -52,6 +53,49 @@ struct qpnp_vib {
 
 static struct qpnp_vib *vib_dev;
 
+static ssize_t qpnp_vib_level_show(struct device *dev,
+                                        struct device_attribute *attr,
+                                        char *buf)
+{
+        struct timed_output_dev *tdev = dev_get_drvdata(dev);
+        struct qpnp_vib *vib = container_of(tdev, struct qpnp_vib,
+                                         timed_dev);
+
+        return scnprintf(buf, PAGE_SIZE, "%d\n", vib->vtg_level);
+}
+
+
+static ssize_t qpnp_vib_level_store(struct device *dev,
+                                        struct device_attribute *attr,
+                                        const char *buf, size_t count)
+{
+        struct timed_output_dev *tdev = dev_get_drvdata(dev);
+        struct qpnp_vib *vib = container_of(tdev, struct qpnp_vib,
+                                         timed_dev);
+        int val;
+        int rc;
+
+        rc = kstrtoint(buf, 10, &val);
+        if (rc) {
+                pr_err("%s: error getting level\n", __func__);
+                return -EINVAL;
+        }
+
+        if (val < QPNP_VIB_MIN_LEVEL) {
+                pr_err("%s: level %d not in range (%d - %d), using min.", __func__, val, QPNP_VIB_MIN_LEVEL, QPNP_VIB_MAX_LEVEL);
+                val = QPNP_VIB_MIN_LEVEL;
+        } else if (val > QPNP_VIB_MAX_LEVEL) {
+                pr_err("%s: level %d not in range (%d - %d), using max.", __func__, val, QPNP_VIB_MIN_LEVEL, QPNP_VIB_MAX_LEVEL);
+                val = QPNP_VIB_MAX_LEVEL;
+        }
+
+        vib->vtg_level = val;
+
+        return strnlen(buf, count);
+}
+
+static DEVICE_ATTR(vtg_level, S_IRUGO | S_IWUSR, qpnp_vib_level_show, qpnp_vib_level_store);
+
 static int qpnp_vib_read_u8(struct qpnp_vib *vib, u8 *data, u16 reg)
 {
 	int rc;
@@ -294,6 +338,8 @@ static int __devinit qpnp_vibrator_probe(struct spmi_device *spmi)
 	if (rc < 0)
 		return rc;
 
+		device_create_file(vib->timed_dev.dev, &dev_attr_vtg_level);
+
 	vib_dev = vib;
 
 	return rc;
-- 
2.5.0

